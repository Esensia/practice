유형 : 그리디
난이도 : 프로그래머스 2
비슷한 유형의 문제 : 프로그래머스 단속카메라
소스 :
import java.util.*;
class Solution {
    public int solution(int[][] customer) {
        int answer = 0;

        Arrays.sort(customer, (a,b) -> a[0]-b[0]);
        int start = customer[0][0];
        int end = customer[0][1];
        for(int i=1;i<customer.length;i++){

            if(end >= customer[i][0]){
                end = Math.max(end,customer[i][1]);
            }
            else {
                answer += (end - start);
                end = customer[i][1];
                start = customer[i][0];
            }
        }
        answer += (end-start);
        return answer;
    }
}

유형 : 구현
난이도 : 프로그래머스 1~2
소스 :
class Solution {
    // 다른걸 낸 한명의 인덱스를 찾기위한 함수
    private int findPerson(String[] person, String target){
        for(int i=0;i<person.length;i++){
            if(target.equals(person[i])){
                return i;
            }
        }
        return 0;
    }
    // 승자가 두명인 경우 패자의 인덱스를 제외한 나머지 승자들의 점수를 계산
    private int[] calculate(int idx, int[] result){
        int first = -1;
        int x = 0;
        for(int i=0;i<3;i++){
            if(i!=idx && first == -1){
                first = result[i];
                x = i;
            }
            else if(i!=idx && first!=-1){
                if(first == result[i]){
                    result[x]+=1;
                    result[i]+=1;
                } else if(first > result[i]){
                    result[i]+=2;
                } else {
                    result[x]+=2;
                }
            }
        }
        return result;
    } 

    private int[] rockPaperSisor(String[] person, int[] result){

        int rCount = 0;
        int pCount = 0;
        int sCount = 0;
        for(int i=0;i<person.length;i++){
            if(person[i].equals("R")){
                rCount++;
            } else if(person[i].equals("P")){
                pCount++;
            } else{
                sCount++;
            }
        }

        // 승자가 1명인 경우
        if(rCount == 2 && pCount == 1){
            result[findPerson(person,"P")]+=2;
        } else if(sCount == 2 && rCount == 1){
            result[findPerson(person,"R")]+=2;
        } else if(pCount ==2 && sCount == 1){
            result[findPerson(person,"S")]+=2;
        }
        // 승자가 2명인 경우
        int idx = 0;
        if(rCount == 2 && sCount == 1){
            idx = findPerson(person,"S");
            result = calculate(idx,result);
        } else if(sCount == 2 && pCount == 1){
            idx = findPerson(person,"P");
            result = calculate(idx,result);
        } else if(pCount ==2 && rCount == 1){
            idx = findPerson(person,"R");
            result = calculate(idx,result);
        }
        return result;
    }

    public int[] solution(String[] rsp3) {
        int[] answer = {0,0,0};

        for(String rsp : rsp3){
            String[] person = rsp.split("");
            answer = rockPaperSisor(person,answer);

        }

        return answer;
    }
}

유형 : 수학
난이도 : 프로그래머스 3
모든 부분집합의 멱급수를 더하고 q제곱한 모든 합을 구하는 문제
dfs완전탐색으로 구현했으나 n의 범위가 5000까지라 2**5000 -1 은 당연히 시간초과
못풀고 제출
소스 :
import java.util.*;
class Solution {
    long answer = 0;

    private void dfs(int idx, int k,long sum, long[]numbers, boolean[] visited,int q, int r){

        if(sum != 0){
            answer += Math.pow(sum,q);
            answer %= 1000000007;
        }
        for(int i=idx;i<numbers.length;i++){
            if(!visited[i]){
                visited[i] = true;
                dfs(i+1,k+1,(sum + (long)Math.pow(r,k) * numbers[i])%1000000007,numbers,visited, q, r);
                visited[i] = false;
            }
        }
    }

    public long solution(long[] numbers, int q, int r) {

        Arrays.sort(numbers);
        boolean[] visited = new boolean[numbers.length];
        dfs(0,0,0,numbers,visited,q,r);
        return answer;
    }
}

유형 : 조인
SELECT B.NAME, COUNT(B.NAME) AS COUNT
FROM CARTS A,
CART_PRODUCTS B
WHERE A.USER_ID = 4
AND A.ID = B.CART_ID
GROUP BY B.NAME
ORDER BY COUNT DESC, B.NAME

유형 : GROUP BY, SUM, DECODE
SELECT SALE_YM "판매년월",
SUM(DECODE(GOODS_CD,'0001',SALE_CNT)) "상품0001판매개수",
SUM(DECODE(GOODS_CD,'0002',SALE_CNT)) "상품0002판매개수",
SUM(DECODE(GOODS_CD,'0003',SALE_CNT)) "상품0003판매개수",
SUM(DECODE(GOODS_CD,'0004',SALE_CNT)) "상품0004판매개수",
SUM(DECODE(GOODS_CD,'0005',SALE_CNT)) "상품0005판매개수",
SUM(SALE_CNT) "전체판매개수"
FROM KKB_GOODS_S
GROUP BY SALE_YM
ORDER BY SALE_YM

제출하면 채점이 다 돼서 4/5솔..
3번문제가 걸리긴 하지만 기술면접 대비해야...
